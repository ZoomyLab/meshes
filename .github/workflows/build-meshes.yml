name: Build Meshes and Upload to Release

on:
  push:
    paths:
      - "**/*.geo"
      - "blacklist.txt"

  workflow_dispatch:
    inputs:
      full_rebuild:
        description: "Rebuild ALL meshes (ignore git diff)?"
        required: false
        default: "false"

jobs:
  build-meshes:
    runs-on: ubuntu-latest

    permissions:
      contents: write   # Required for creating releases + uploading assets

    steps:
    - uses: actions/checkout@v4
      with:
        # we want at least HEAD and HEAD~1, and tags later
        fetch-depth: 0

    - name: Fetch tags
      run: git fetch --tags --force

    - name: Install gmsh
      run: sudo apt-get update && sudo apt-get install -y gmsh

    - name: Determine .geo files to process
      id: changed
      run: |
        echo "Manual full rebuild: '${{ github.event.inputs.full_rebuild }}'"

        if [[ "${{ github.event.inputs.full_rebuild }}" == "true" ]]; then
          echo "Doing FULL rebuild: selecting ALL .geo files."
          CHANGED=$(git ls-files '**/*.geo')
        else
          # Try diff, fallback to all files if HEAD~1 missing
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            CHANGED=$(git diff --name-only HEAD~1 HEAD -- '**/*.geo')
          else
            echo "HEAD~1 missing â€” treating all .geo as changed."
            CHANGED=$(git ls-files '**/*.geo')
          fi
        fi

        echo "CHANGED:"
        echo "$CHANGED"

        # Load blacklist (one entry per line, e.g. "old" or "old/channel_2d_hole/mesh.geo")
        BLACKLIST=$(cat blacklist.txt | tr '\n' ' ')
        echo "BLACKLIST: $BLACKLIST"

        FILTERED=""
        for f in $CHANGED; do
          SKIP=0
          for b in $BLACKLIST; do
            # If b is "old", this will skip any path starting with "old/"
            # If b is a full file path, it will match exactly.
            if [[ "$f" == "$b" || "$f" == "$b/"* ]]; then
              SKIP=1
              break
            fi
          done
          [[ $SKIP == 0 ]] && FILTERED="$FILTERED $f"
        done

        echo "FILES TO RUN:"
        echo "$FILTERED"

        echo "files=$FILTERED" >> $GITHUB_OUTPUT

    - name: Run mesh generation
      if: steps.changed.outputs.files != ''
      run: |
        for f in ${{ steps.changed.outputs.files }}; do
          DIR=$(dirname "$f")
          echo "Generating mesh in: $DIR"

          if [[ -f "$DIR/run.sh" ]]; then
            (cd "$DIR" && chmod +x run.sh && ./run.sh)
          else
            echo "::warning ::No run.sh found in '$DIR', skipping."
          fi
        done

    # ---- SEMANTIC VERSIONING ----
    - name: Determine next version
      id: version
      run: |
        # Get latest tag matching meshes-v*
        LATEST=$(git tag --list "meshes-v*" --sort=-v:refname | head -n 1)
        echo "Latest tag: $LATEST"

        if [[ -z "$LATEST" ]]; then
          NEXT="meshes-v0.1.0"
        else
          BASE=${LATEST#meshes-v}
          IFS='.' read -r MAJ MIN PATCH <<< "$BASE"
          PATCH=$((PATCH+1))
          NEXT="meshes-v$MAJ.$MIN.$PATCH"
        fi

        echo "Next tag: $NEXT"
        echo "tag=$NEXT" >> $GITHUB_OUTPUT

    # ---- CREATE RELEASE ----
    - name: Create Release
      if: steps.changed.outputs.files != ''
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.version.outputs.tag }}
        name: "Meshes Release ${{ steps.version.outputs.tag }}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # ---- UPLOAD ASSETS WITH FULL PATHS ----
    - name: Upload meshes with folder structure preserved
      if: steps.changed.outputs.files != ''
      run: |
        TAG=${{ steps.version.outputs.tag }}

        shopt -s globstar
        ANY=0
        for f in **/*.msh; do
          # Skip workflow cruft
          [[ "$f" == .github/* ]] && continue
          [[ -f "$f" ]] || continue
          ANY=1
          echo "Uploading $f"
          gh release upload "$TAG" "$f" --clobber --name "$f"
        done

        if [[ $ANY -eq 0 ]]; then
          echo "No .msh files found to upload."
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
