name: Build Meshes and Upload to Release

on:
  push:
    paths:
      - "**/*.geo"
      - "blacklist.txt"

  workflow_dispatch:
    inputs:
      full_rebuild:
        description: "Rebuild ALL meshes (ignore git diff)?"
        required: false
        default: "false"

jobs:
  build-meshes:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0   # we need tags + full history for semantic versioning

    - name: Fetch all tags
      run: git fetch --tags --force

    - name: Install gmsh
      run: sudo apt-get update && sudo apt-get install -y gmsh

    - name: Determine .geo files to process
      id: changed
      run: |
        echo "Manual full rebuild: '${{ github.event.inputs.full_rebuild }}'"

        if [[ "${{ github.event.inputs.full_rebuild }}" == "true" ]]; then
          echo "FULL REBUILD: selecting ALL .geo files."
          CHANGED=$(git ls-files '**/*.geo')
        else
          if git rev-parse HEAD~1 >/dev/null 2>&1; then
            CHANGED=$(git diff --name-only HEAD~1 HEAD -- '**/*.geo')
          else
            echo "HEAD~1 missing â€” selecting all .geo."
            CHANGED=$(git ls-files '**/*.geo')
          fi
        fi

        echo "CHANGED FILES:"
        echo "$CHANGED"

        BLACKLIST=$(cat blacklist.txt | tr '\n' ' ')
        echo "BLACKLIST: $BLACKLIST"

        FILTERED=""
        for f in $CHANGED; do
          SKIP=0
          for b in $BLACKLIST; do
            # Skip folder "old/" and any file or subpath inside it
            if [[ "$f" == "$b" || "$f" == "$b/"* ]]; then
              SKIP=1
              break
            fi
          done
          [[ $SKIP == 0 ]] && FILTERED="$FILTERED $f"
        done

        echo "FILES TO RUN:"
        echo "$FILTERED"

        echo "files=$FILTERED" >> $GITHUB_OUTPUT

    - name: Run mesh generation
      if: steps.changed.outputs.files != ''
      run: |
        for f in ${{ steps.changed.outputs.files }}; do
          DIR=$(dirname "$f")
          echo "Generating mesh in: $DIR"

          if [[ -f "$DIR/run.sh" ]]; then
            (cd "$DIR" && chmod +x run.sh && ./run.sh)
          else
            echo "::warning ::No run.sh found in '$DIR', skipping."
          fi
        done

    # ---- SEMANTIC VERSIONING ----
    - name: Determine next version
      id: version
      run: |
        LATEST=$(git tag --list "meshes-v*" --sort=-v:refname | head -n 1)
        echo "Latest tag: $LATEST"

        if [[ -z "$LATEST" ]]; then
          NEXT="meshes-v0.1.0"
        else
          BASE=${LATEST#meshes-v}
          IFS='.' read -r MAJ MIN PATCH <<< "$BASE"
          PATCH=$((PATCH+1))
          NEXT="meshes-v$MAJ.$MIN.$PATCH"
        fi

        echo "Next tag: $NEXT"
        echo "tag=$NEXT" >> $GITHUB_OUTPUT

    # ---- CREATE RELEASE ----
    - name: Create Release
      if: steps.changed.outputs.files != ''
      uses: softprops/action-gh-release@v2
      with:
        tag_name: ${{ steps.version.outputs.tag }}
        name: "Meshes Release ${{ steps.version.outputs.tag }}"
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # ---- UPLOAD ASSETS WITH FOLDER STRUCTURE ----
    - name: Upload meshes with folder structure preserved
      if: steps.changed.outputs.files != ''
      run: |
        TAG=${{ steps.version.outputs.tag }}

        echo "Preparing assets for release $TAG"

        mkdir -p release_assets

        shopt -s globstar
        ANY=0
        for f in meshes/**/*.msh; do
          [[ -f "$f" ]] || continue
          ANY=1

          OUT="release_assets/$f"

          # Mirror directory structure
          mkdir -p "$(dirname "$OUT")"

          cp "$f" "$OUT"

          echo "Prepared asset: $OUT"
        done

        if [[ $ANY -eq 0 ]]; then
          echo "No .msh files found to upload."
        else
          echo "Uploading with gh release upload..."
          gh release upload "$TAG" release_assets/** --clobber
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
